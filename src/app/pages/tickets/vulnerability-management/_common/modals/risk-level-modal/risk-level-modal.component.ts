import { Component, Inject, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MinLength, MaxLength } from 'src/app/shared/constants';
import { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';
import { MaintainersService } from 'src/app/core/_services/maintainers.service';
import { ValidatorsService } from 'src/app/core/_services/validators.service';
import { ObjFile } from 'src/app/core/model/db-ticket.model';
import { forkJoin } from 'rxjs';

@Component({
  selector: 'app-risk-level-modal',
  templateUrl: './risk-level-modal.component.html',
})
export class RiskLevelModalComponent implements OnInit {
  formGroup: FormGroup;

  public minLength = MinLength;
  public maxLength = MaxLength;

  public riskLevels = [];
  public results = [];
  public errorTypeList = [];

  objFile: ObjFile;

  constructor(
    private fb: FormBuilder,
    public dialogRef: MatDialogRef<RiskLevelModalComponent>,
    public validatorService: ValidatorsService,
    private mntService: MaintainersService,
    @Inject(MAT_DIALOG_DATA) public data: any,
  ) { }

  get formControls() {
    return this.formGroup.controls;
  }

  loadForm() {
    this.formGroup = this.fb.group({
      score: ['', Validators.required],
      riskLevel: ['', Validators.required],
      requesterResult: ['', Validators.required],
      errorType: ['', Validators.required],
    });
  }

  ngOnInit(): void {
    this.getInitialData();
    this.loadForm();
    this.checkObservable();
  }

  checkObservable() {
    if (this.data.updateRow) {
      this.formGroup.patchValue(this.data.updateRow);
      this.formGroup.controls["riskLevel"].setValue(this.data.updateRow.riskLevel);
      this.objFile = this.data.updateRow.report;
    }
  }

  closeModal() {
    this.dialogRef.close();
  }

  save() {
    let obj = this.formGroup.getRawValue();
    this.data.updateRow.score = obj.score;
    this.data.updateRow.riskLevel = obj.riskLevel;
    this.data.updateRow.requesterResult = obj.requesterResult;
    this.data.updateRow.errorType = obj.errorType;
    this.data.updateRow.report = this.objFile;
    this.dialogRef.close(this.data.updateRow);
  }

  getFileByControl(control) {
    return this.objFile;
  }

  pushObjFile(objFile: ObjFile) {
    this.objFile = objFile;
  }

  onFileSelected(files: FileList) {
    let file = files[0];
    let reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      console.log(file.name);
      let uploaded = { name: file.name, fileData: reader.result.toString().split(',').pop(), nameControl: 'report' + this.data.updateRow.index };
      this.objFile = uploaded;
    };
    reader.onerror = (error) => {
      console.log('Error: ', error);
    };
  }

  downloadFile() {
    const blob = this.b64toBlob(this.objFile.fileData, 'application/octet-stream');
    const blobUrl = URL.createObjectURL(blob);
    if (window.navigator.msSaveBlob) { // // IE hack; see http://msdn.microsoft.com/en-us/library/ie/hh779016.aspx
      window.navigator.msSaveOrOpenBlob(blob, this.objFile.name);
    }
    else {
      var a = window.document.createElement("a");
      a.href = window.URL.createObjectURL(blob);
      a.download = this.objFile.name;
      document.body.appendChild(a);
      a.click();  // IE: "Access is denied"; see: https://connect.microsoft.com/IE/feedback/details/797361/ie-10-treats-blob-url-as-cross-origin-and-denies-access
      document.body.removeChild(a);
    }
  }

  b64toBlob(b64Data, contentType = '', sliceSize = 512) {
    const byteCharacters = atob(b64Data);
    const byteArrays = [];

    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
      const slice = byteCharacters.slice(offset, offset + sliceSize);

      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }

      const byteArray = new Uint8Array(byteNumbers);
      byteArrays.push(byteArray);
    }

    const blob = new Blob(byteArrays, { type: contentType });
    return blob;
  }

  compareObjects(object1: any, object2: any) {
    return object1 && object2 && object1.id == object2.id;
  }

  getInitialData() {
    forkJoin([
      this.mntService.getRiskLevels(),
      this.mntService.getRequesterResults(),
      this.mntService.getErrorTypeList(),
    ]).subscribe(([res1, res2, res3]) => {
      this.riskLevels = res1;
      this.results = res2;
      this.errorTypeList = res3;
    })
  }
}
